Mode 1: Predefined ODEs (user chooses from a list)
Mode 2: User inputs the ODE as a string in terms of 't' and 'y'

We'll structure the code as:

    A function for Euler method:
    def euler_method(f, y0, t0, h, n):
    t = t0
    y = y0
    results = [(t0, y0)]
    for i in range(n):
    y = y + h * f(t, y)
    t = t + h
    results.append((t, y))
    return results

    A function for RK4 method:
    def rk4_method(f, y0, t0, h, n):
    t = t0
    y = y0
    results = [(t0, y0)]
    for i in range(n):
    k1 = h * f(t, y)
    k2 = h * f(t + h/2, y + k1/2)
    k3 = h * f(t + h/2, y + k2/2)
    k4 = h * f(t + h, y + k3)
    y = y + (k1 + 2*k2 + 2*k3 + k4) / 6
    t = t + h
    results.append((t, y))
    return results

    A function to parse the string ODE and create a function f(t, y) using eval (with a warning).

    Main function that interacts with the user.

Let's create a safe way to evaluate the string by restricting the built-ins? We can use a dictionary of allowed functions and variables.

We'll allow:
t, y, math functions (sin, cos, exp, etc.)

Example of allowed namespace:

import math
allowed_names = { 'sin': math.sin, 'cos': math.cos, 'exp': math.exp, ... }

Then we can do:
f = eval(ode_string, {"builtins": None}, allowed_names)

But note: we also need to allow t and y. So we'll update the allowed_names with the current t and y.

However, we cannot do that because t and y are variables that change. Instead, we can create a function that takes t and y and then evaluates the string in the context of allowed_names plus t and y.

Let's define:

def make_ode_function(ode_string):
# We'll create a function that takes t and y and returns the value of the expression
# We'll use a lambda function that uses eval with a context that includes math functions and t and y.
import math
allowed_names = {key: getattr(math, key) for key in dir(math) if not key.startswith("__")}
allowed_names['t'] = 0
allowed_names['y'] = 0
# But we want to evaluate the string with the given t and y. So we update the allowed_names for each call?
# Instead, we can do:
def f(t, y):
allowed_names['t'] = t
allowed_names['y'] = y
return eval(ode_string, {"builtins": None}, allowed_names)
return f

But note: this is still risky if the user inputs malicious code. We are only allowing math functions and t and y, but what if the string contains something else? We are restricting the builtins, but the user might try to access other modules through math? Actually, we are only allowing the attributes of math that are functions and constants. This should be safe enough for educational use.

Alternatively, we can use a more robust expression evaluator, but for simplicity we'll use this.

Let's code accordingly.

We'll also provide an option to input the function as a lambda function if the user is running the code in an environment where they can write Python.

But for the string input, we'll use the above method.

Steps for main:

    Ask the user if they want to input the ODE as a string or use a predefined one.

    If predefined, list some examples (like exponential growth, logistic growth, etc.)

    Then ask for initial conditions, step size, and number of steps.

    Ask for the method (Euler or RK4).

    Compute and print the results.

Let's code accordingly.

We'll also plot the results using matplotlib if available.

Let's add an option to plot.

We'll structure the code in a way that if matplotlib is installed, we plot, else we just print the table.

We can check for matplotlib and if not found, print a message.

Let's code accordingly.